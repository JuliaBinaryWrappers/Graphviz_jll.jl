# Autogenerated wrapper script for Graphviz_jll for i686-linux-gnu-cxx11
export acyclic, bcomps, ccomps, circo, cluster, dijkstra, dot, dot2gxl, dot_builtins, edgepaint, fdp, gc, gml2gv, graphml2gv, gv2gml, gv2gxl, gvcolor, gvgen, gvmap, gvmap_sh, gvpack, gvpr, gxl2dot, gxl2gv, libcdt, libcgraph, libgvc, libgvpr, liblab_gamut, libpathplan, libxdot, mm2gv, neato, nop, osage, patchwork, prune, sccmap, sfdp, tred, twopi, unflatten

using Cairo_jll
using Expat_jll
using Pango_jll
## Global variables
PATH = ""
LIBPATH = ""
LIBPATH_env = "LD_LIBRARY_PATH"
LIBPATH_default = ""

# Relative path to `acyclic`
const acyclic_splitpath = ["bin", "acyclic"]

# This will be filled out by __init__() for all products, as it must be done at runtime
acyclic_path = ""

# acyclic-specific global declaration
function acyclic(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(acyclic_path)
    end
end


# Relative path to `bcomps`
const bcomps_splitpath = ["bin", "bcomps"]

# This will be filled out by __init__() for all products, as it must be done at runtime
bcomps_path = ""

# bcomps-specific global declaration
function bcomps(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(bcomps_path)
    end
end


# Relative path to `ccomps`
const ccomps_splitpath = ["bin", "ccomps"]

# This will be filled out by __init__() for all products, as it must be done at runtime
ccomps_path = ""

# ccomps-specific global declaration
function ccomps(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(ccomps_path)
    end
end


# Relative path to `circo`
const circo_splitpath = ["bin", "circo"]

# This will be filled out by __init__() for all products, as it must be done at runtime
circo_path = ""

# circo-specific global declaration
function circo(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(circo_path)
    end
end


# Relative path to `cluster`
const cluster_splitpath = ["bin", "cluster"]

# This will be filled out by __init__() for all products, as it must be done at runtime
cluster_path = ""

# cluster-specific global declaration
function cluster(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(cluster_path)
    end
end


# Relative path to `dijkstra`
const dijkstra_splitpath = ["bin", "dijkstra"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dijkstra_path = ""

# dijkstra-specific global declaration
function dijkstra(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dijkstra_path)
    end
end


# Relative path to `dot`
const dot_splitpath = ["bin", "dot"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dot_path = ""

# dot-specific global declaration
function dot(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dot_path)
    end
end


# Relative path to `dot2gxl`
const dot2gxl_splitpath = ["bin", "dot2gxl"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dot2gxl_path = ""

# dot2gxl-specific global declaration
function dot2gxl(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dot2gxl_path)
    end
end


# Relative path to `dot_builtins`
const dot_builtins_splitpath = ["bin", "dot_builtins"]

# This will be filled out by __init__() for all products, as it must be done at runtime
dot_builtins_path = ""

# dot_builtins-specific global declaration
function dot_builtins(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(dot_builtins_path)
    end
end


# Relative path to `edgepaint`
const edgepaint_splitpath = ["bin", "edgepaint"]

# This will be filled out by __init__() for all products, as it must be done at runtime
edgepaint_path = ""

# edgepaint-specific global declaration
function edgepaint(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(edgepaint_path)
    end
end


# Relative path to `fdp`
const fdp_splitpath = ["bin", "fdp"]

# This will be filled out by __init__() for all products, as it must be done at runtime
fdp_path = ""

# fdp-specific global declaration
function fdp(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(fdp_path)
    end
end


# Relative path to `gc`
const gc_splitpath = ["bin", "gc"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gc_path = ""

# gc-specific global declaration
function gc(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gc_path)
    end
end


# Relative path to `gml2gv`
const gml2gv_splitpath = ["bin", "gml2gv"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gml2gv_path = ""

# gml2gv-specific global declaration
function gml2gv(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gml2gv_path)
    end
end


# Relative path to `graphml2gv`
const graphml2gv_splitpath = ["bin", "graphml2gv"]

# This will be filled out by __init__() for all products, as it must be done at runtime
graphml2gv_path = ""

# graphml2gv-specific global declaration
function graphml2gv(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(graphml2gv_path)
    end
end


# Relative path to `gv2gml`
const gv2gml_splitpath = ["bin", "gv2gml"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gv2gml_path = ""

# gv2gml-specific global declaration
function gv2gml(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gv2gml_path)
    end
end


# Relative path to `gv2gxl`
const gv2gxl_splitpath = ["bin", "gv2gxl"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gv2gxl_path = ""

# gv2gxl-specific global declaration
function gv2gxl(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gv2gxl_path)
    end
end


# Relative path to `gvcolor`
const gvcolor_splitpath = ["bin", "gvcolor"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gvcolor_path = ""

# gvcolor-specific global declaration
function gvcolor(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gvcolor_path)
    end
end


# Relative path to `gvgen`
const gvgen_splitpath = ["bin", "gvgen"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gvgen_path = ""

# gvgen-specific global declaration
function gvgen(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gvgen_path)
    end
end


# Relative path to `gvmap`
const gvmap_splitpath = ["bin", "gvmap"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gvmap_path = ""

# gvmap-specific global declaration
function gvmap(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gvmap_path)
    end
end


# Relative path to `gvmap_sh`
const gvmap_sh_splitpath = ["bin", "gvmap.sh"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gvmap_sh_path = ""

# gvmap_sh-specific global declaration
function gvmap_sh(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gvmap_sh_path)
    end
end


# Relative path to `gvpack`
const gvpack_splitpath = ["bin", "gvpack"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gvpack_path = ""

# gvpack-specific global declaration
function gvpack(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gvpack_path)
    end
end


# Relative path to `gvpr`
const gvpr_splitpath = ["bin", "gvpr"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gvpr_path = ""

# gvpr-specific global declaration
function gvpr(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gvpr_path)
    end
end


# Relative path to `gxl2dot`
const gxl2dot_splitpath = ["bin", "gxl2dot"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gxl2dot_path = ""

# gxl2dot-specific global declaration
function gxl2dot(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gxl2dot_path)
    end
end


# Relative path to `gxl2gv`
const gxl2gv_splitpath = ["bin", "gxl2gv"]

# This will be filled out by __init__() for all products, as it must be done at runtime
gxl2gv_path = ""

# gxl2gv-specific global declaration
function gxl2gv(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(gxl2gv_path)
    end
end


# Relative path to `libcdt`
const libcdt_splitpath = ["lib", "libcdt.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcdt_path = ""

# libcdt-specific global declaration
# This will be filled out by __init__()
libcdt_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcdt = "libcdt.so.5"


# Relative path to `libcgraph`
const libcgraph_splitpath = ["lib", "libcgraph.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libcgraph_path = ""

# libcgraph-specific global declaration
# This will be filled out by __init__()
libcgraph_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libcgraph = "libcgraph.so.6"


# Relative path to `libgvc`
const libgvc_splitpath = ["lib", "libgvc.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libgvc_path = ""

# libgvc-specific global declaration
# This will be filled out by __init__()
libgvc_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libgvc = "libgvc.so.6"


# Relative path to `libgvpr`
const libgvpr_splitpath = ["lib", "libgvpr.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libgvpr_path = ""

# libgvpr-specific global declaration
# This will be filled out by __init__()
libgvpr_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libgvpr = "libgvpr.so.2"


# Relative path to `liblab_gamut`
const liblab_gamut_splitpath = ["lib", "liblab_gamut.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
liblab_gamut_path = ""

# liblab_gamut-specific global declaration
# This will be filled out by __init__()
liblab_gamut_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const liblab_gamut = "liblab_gamut.so.1"


# Relative path to `libpathplan`
const libpathplan_splitpath = ["lib", "libpathplan.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libpathplan_path = ""

# libpathplan-specific global declaration
# This will be filled out by __init__()
libpathplan_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libpathplan = "libpathplan.so.4"


# Relative path to `libxdot`
const libxdot_splitpath = ["lib", "libxdot.so"]

# This will be filled out by __init__() for all products, as it must be done at runtime
libxdot_path = ""

# libxdot-specific global declaration
# This will be filled out by __init__()
libxdot_handle = C_NULL

# This must be `const` so that we can use it with `ccall()`
const libxdot = "libxdot.so.4"


# Relative path to `mm2gv`
const mm2gv_splitpath = ["bin", "mm2gv"]

# This will be filled out by __init__() for all products, as it must be done at runtime
mm2gv_path = ""

# mm2gv-specific global declaration
function mm2gv(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(mm2gv_path)
    end
end


# Relative path to `neato`
const neato_splitpath = ["bin", "neato"]

# This will be filled out by __init__() for all products, as it must be done at runtime
neato_path = ""

# neato-specific global declaration
function neato(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(neato_path)
    end
end


# Relative path to `nop`
const nop_splitpath = ["bin", "nop"]

# This will be filled out by __init__() for all products, as it must be done at runtime
nop_path = ""

# nop-specific global declaration
function nop(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(nop_path)
    end
end


# Relative path to `osage`
const osage_splitpath = ["bin", "osage"]

# This will be filled out by __init__() for all products, as it must be done at runtime
osage_path = ""

# osage-specific global declaration
function osage(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(osage_path)
    end
end


# Relative path to `patchwork`
const patchwork_splitpath = ["bin", "patchwork"]

# This will be filled out by __init__() for all products, as it must be done at runtime
patchwork_path = ""

# patchwork-specific global declaration
function patchwork(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(patchwork_path)
    end
end


# Relative path to `prune`
const prune_splitpath = ["bin", "prune"]

# This will be filled out by __init__() for all products, as it must be done at runtime
prune_path = ""

# prune-specific global declaration
function prune(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(prune_path)
    end
end


# Relative path to `sccmap`
const sccmap_splitpath = ["bin", "sccmap"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sccmap_path = ""

# sccmap-specific global declaration
function sccmap(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sccmap_path)
    end
end


# Relative path to `sfdp`
const sfdp_splitpath = ["bin", "sfdp"]

# This will be filled out by __init__() for all products, as it must be done at runtime
sfdp_path = ""

# sfdp-specific global declaration
function sfdp(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(sfdp_path)
    end
end


# Relative path to `tred`
const tred_splitpath = ["bin", "tred"]

# This will be filled out by __init__() for all products, as it must be done at runtime
tred_path = ""

# tred-specific global declaration
function tred(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(tred_path)
    end
end


# Relative path to `twopi`
const twopi_splitpath = ["bin", "twopi"]

# This will be filled out by __init__() for all products, as it must be done at runtime
twopi_path = ""

# twopi-specific global declaration
function twopi(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(twopi_path)
    end
end


# Relative path to `unflatten`
const unflatten_splitpath = ["bin", "unflatten"]

# This will be filled out by __init__() for all products, as it must be done at runtime
unflatten_path = ""

# unflatten-specific global declaration
function unflatten(f::Function; adjust_PATH::Bool = true, adjust_LIBPATH::Bool = true)
    global PATH, LIBPATH
    env_mapping = Dict{String,String}()
    if adjust_PATH
        if !isempty(get(ENV, "PATH", ""))
            env_mapping["PATH"] = string(PATH, ':', ENV["PATH"])
        else
            env_mapping["PATH"] = PATH
        end
    end
    if adjust_LIBPATH
        LIBPATH_base = get(ENV, LIBPATH_env, expanduser(LIBPATH_default))
        if !isempty(LIBPATH_base)
            env_mapping[LIBPATH_env] = string(LIBPATH, ':', LIBPATH_base)
        else
            env_mapping[LIBPATH_env] = LIBPATH
        end
    end
    withenv(env_mapping...) do
        f(unflatten_path)
    end
end


"""
Open all libraries
"""
function __init__()
    global artifact_dir = abspath(artifact"Graphviz")

    # Initialize PATH and LIBPATH environment variable listings
    global PATH_list, LIBPATH_list
    # From the list of our dependencies, generate a tuple of all the PATH and LIBPATH lists,
    # then append them to our own.
    foreach(p -> append!(PATH_list, p), (Cairo_jll.PATH_list, Expat_jll.PATH_list, Pango_jll.PATH_list,))
    foreach(p -> append!(LIBPATH_list, p), (Cairo_jll.LIBPATH_list, Expat_jll.LIBPATH_list, Pango_jll.LIBPATH_list,))

    global acyclic_path = normpath(joinpath(artifact_dir, acyclic_splitpath...))

    push!(PATH_list, dirname(acyclic_path))
    global bcomps_path = normpath(joinpath(artifact_dir, bcomps_splitpath...))

    push!(PATH_list, dirname(bcomps_path))
    global ccomps_path = normpath(joinpath(artifact_dir, ccomps_splitpath...))

    push!(PATH_list, dirname(ccomps_path))
    global circo_path = normpath(joinpath(artifact_dir, circo_splitpath...))

    push!(PATH_list, dirname(circo_path))
    global cluster_path = normpath(joinpath(artifact_dir, cluster_splitpath...))

    push!(PATH_list, dirname(cluster_path))
    global dijkstra_path = normpath(joinpath(artifact_dir, dijkstra_splitpath...))

    push!(PATH_list, dirname(dijkstra_path))
    global dot_path = normpath(joinpath(artifact_dir, dot_splitpath...))

    push!(PATH_list, dirname(dot_path))
    global dot2gxl_path = normpath(joinpath(artifact_dir, dot2gxl_splitpath...))

    push!(PATH_list, dirname(dot2gxl_path))
    global dot_builtins_path = normpath(joinpath(artifact_dir, dot_builtins_splitpath...))

    push!(PATH_list, dirname(dot_builtins_path))
    global edgepaint_path = normpath(joinpath(artifact_dir, edgepaint_splitpath...))

    push!(PATH_list, dirname(edgepaint_path))
    global fdp_path = normpath(joinpath(artifact_dir, fdp_splitpath...))

    push!(PATH_list, dirname(fdp_path))
    global gc_path = normpath(joinpath(artifact_dir, gc_splitpath...))

    push!(PATH_list, dirname(gc_path))
    global gml2gv_path = normpath(joinpath(artifact_dir, gml2gv_splitpath...))

    push!(PATH_list, dirname(gml2gv_path))
    global graphml2gv_path = normpath(joinpath(artifact_dir, graphml2gv_splitpath...))

    push!(PATH_list, dirname(graphml2gv_path))
    global gv2gml_path = normpath(joinpath(artifact_dir, gv2gml_splitpath...))

    push!(PATH_list, dirname(gv2gml_path))
    global gv2gxl_path = normpath(joinpath(artifact_dir, gv2gxl_splitpath...))

    push!(PATH_list, dirname(gv2gxl_path))
    global gvcolor_path = normpath(joinpath(artifact_dir, gvcolor_splitpath...))

    push!(PATH_list, dirname(gvcolor_path))
    global gvgen_path = normpath(joinpath(artifact_dir, gvgen_splitpath...))

    push!(PATH_list, dirname(gvgen_path))
    global gvmap_path = normpath(joinpath(artifact_dir, gvmap_splitpath...))

    push!(PATH_list, dirname(gvmap_path))
    global gvmap_sh_path = normpath(joinpath(artifact_dir, gvmap_sh_splitpath...))

    push!(PATH_list, dirname(gvmap_sh_path))
    global gvpack_path = normpath(joinpath(artifact_dir, gvpack_splitpath...))

    push!(PATH_list, dirname(gvpack_path))
    global gvpr_path = normpath(joinpath(artifact_dir, gvpr_splitpath...))

    push!(PATH_list, dirname(gvpr_path))
    global gxl2dot_path = normpath(joinpath(artifact_dir, gxl2dot_splitpath...))

    push!(PATH_list, dirname(gxl2dot_path))
    global gxl2gv_path = normpath(joinpath(artifact_dir, gxl2gv_splitpath...))

    push!(PATH_list, dirname(gxl2gv_path))
    global libcdt_path = normpath(joinpath(artifact_dir, libcdt_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcdt_handle = dlopen(libcdt_path)
    push!(LIBPATH_list, dirname(libcdt_path))

    global libcgraph_path = normpath(joinpath(artifact_dir, libcgraph_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libcgraph_handle = dlopen(libcgraph_path)
    push!(LIBPATH_list, dirname(libcgraph_path))

    global libgvc_path = normpath(joinpath(artifact_dir, libgvc_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libgvc_handle = dlopen(libgvc_path)
    push!(LIBPATH_list, dirname(libgvc_path))

    global libgvpr_path = normpath(joinpath(artifact_dir, libgvpr_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libgvpr_handle = dlopen(libgvpr_path)
    push!(LIBPATH_list, dirname(libgvpr_path))

    global liblab_gamut_path = normpath(joinpath(artifact_dir, liblab_gamut_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global liblab_gamut_handle = dlopen(liblab_gamut_path)
    push!(LIBPATH_list, dirname(liblab_gamut_path))

    global libpathplan_path = normpath(joinpath(artifact_dir, libpathplan_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libpathplan_handle = dlopen(libpathplan_path)
    push!(LIBPATH_list, dirname(libpathplan_path))

    global libxdot_path = normpath(joinpath(artifact_dir, libxdot_splitpath...))

    # Manually `dlopen()` this right now so that future invocations
    # of `ccall` with its `SONAME` will find this path immediately.
    global libxdot_handle = dlopen(libxdot_path)
    push!(LIBPATH_list, dirname(libxdot_path))

    global mm2gv_path = normpath(joinpath(artifact_dir, mm2gv_splitpath...))

    push!(PATH_list, dirname(mm2gv_path))
    global neato_path = normpath(joinpath(artifact_dir, neato_splitpath...))

    push!(PATH_list, dirname(neato_path))
    global nop_path = normpath(joinpath(artifact_dir, nop_splitpath...))

    push!(PATH_list, dirname(nop_path))
    global osage_path = normpath(joinpath(artifact_dir, osage_splitpath...))

    push!(PATH_list, dirname(osage_path))
    global patchwork_path = normpath(joinpath(artifact_dir, patchwork_splitpath...))

    push!(PATH_list, dirname(patchwork_path))
    global prune_path = normpath(joinpath(artifact_dir, prune_splitpath...))

    push!(PATH_list, dirname(prune_path))
    global sccmap_path = normpath(joinpath(artifact_dir, sccmap_splitpath...))

    push!(PATH_list, dirname(sccmap_path))
    global sfdp_path = normpath(joinpath(artifact_dir, sfdp_splitpath...))

    push!(PATH_list, dirname(sfdp_path))
    global tred_path = normpath(joinpath(artifact_dir, tred_splitpath...))

    push!(PATH_list, dirname(tred_path))
    global twopi_path = normpath(joinpath(artifact_dir, twopi_splitpath...))

    push!(PATH_list, dirname(twopi_path))
    global unflatten_path = normpath(joinpath(artifact_dir, unflatten_splitpath...))

    push!(PATH_list, dirname(unflatten_path))
    # Filter out duplicate and empty entries in our PATH and LIBPATH entries
    filter!(!isempty, unique!(PATH_list))
    filter!(!isempty, unique!(LIBPATH_list))
    global PATH = join(PATH_list, ':')
    global LIBPATH = join(vcat(LIBPATH_list, [joinpath(Sys.BINDIR, Base.LIBDIR, "julia"), joinpath(Sys.BINDIR, Base.LIBDIR)]), ':')

    
end  # __init__()

